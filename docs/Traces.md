# Distributed Tracing

Distributed traces record the paths that requests take as they propagate through multi-service architectures, like microservice and serverless applications. Tracing is critical for observability in microservice architectures because it is the only form of telemetry that encodes the dependencies and relationships between the hundreds of components in modern architectures.

So, gathering high-quality tracing telemetry is of the utmost importance; and yet that’s a difficult thing to do without some sort of common approach, since distributed systems involve many different languages, frameworks, and infrastructure components. That’s why OpenTelemetry can help so much with distributed tracing: by providing a common set of APIs, SDKs, and wire protocols, <b>OpenTelemetry gives organizations a single, well-supported integration surface for end-to-end distributed tracing telemetry.</b>

## Microservices and tracing

Microservices introduce significant challenges to tracing a request through an application, thanks to the distributed nature of microservices deployments. Consider a traditional monolithic application: with a code base centralized onto a single host, diagnosing a failure can be as simple as following a single stack trace. But, when an application consists of tens, hundreds, or thousands of services running across many hosts, it is no longer possible to rely on an individual trace. Instead, you need something that represents the entire request as it moves from service to service, component to component. Distributed tracing solves this problem, providing powerful capabilities such as anomaly detection, distributed profiling, workload modeling, and diagnosis of steady-state problems.

## OpenTelemetry and tracing

Much of the terminology and mental models that we use to describe distributed tracing can trace their origin to systems such as [Magpie](https://www.usenix.org/legacy/publications/library/proceedings/hotos03/tech/full_papers/barham/barham_html/paper.html), [X-Trace](https://www.usenix.org/legacy/event/nsdi07/tech/full_papers/fonseca/fonseca.pdf), and [Dapper](https://research.google/pubs/pub36356/). Dapper, in particular, has been highly influential to modern distributed tracing efforts, and many of the mental models and terminology that OpenTelemetry uses can trace their origin to that project. The goal of these distributed tracing efforts has been to profile requests as they move across service boundaries, generating high-quality data about those requests suitable for analysis.

<p align="center"><img src="../images/Traces.png?raw=true"/></p>

The above diagram represents a sample trace. A <b>trace</b> is a collection of linked spans, which are named and timed operations that represent a unit of work in the request. A span that isn’t the child of any other span is the parent span, or root span, of the trace. The root span describes the end-to-end latency of the entire trace, with child spans representing sub-operations.

To put this in more concrete terms, consider the request flow of a system that you might encounter in the real world, a ridesharing app. When a user requests a ride, multiple actions begin to take place –– information is passed between services in order to authenticate and authorize the user, validate payment information, locate nearby drivers, and dispatch one of them to pick up the rider.

A simplified diagram of this system, and a trace of a request through it, appears in the following figure. As you can see, each operation generates a span to represent the work being done during its execution. These spans have implicit relationships (parent-child) both from the beginning of the entire request at the client, but also from individual services in the trace. Traces are composable in this way: a valid trace consists of valid sub-traces.

<p align="center"><img src="../images/Spans.png?raw=true"/></p>

## Spans

A <b>span</b> is the building block of a trace and is a named, timed operation that represents a piece of the workflow in the distributed system. Multiple spans are pieced together to create a trace.

The purpose of a span is to provide information to observability tools about the execution of a program, so it should contain details about the work.

The components of an individual span include:

- Operation name
- Start and finish timestamps
- <i>SpanContext</i>
- Set of <i>Attributes</i>
- Ordered list of <i>Events</i>

### SpanContext

In order for the trace tree to be built with these relationships intact, each span needs to propagate its <b>SpanContext</b> to its child. It may be sent along with a request to a remote system, or to another span generated by the same system. <b>SpanContext</b> tells the child span who its parent is (via the <i>span_ID</i>) and what trace it belongs to (<i>trace_ID</i>).

### Attributes

Attributes are key-value pairs that provide detail about a span. They apply to the whole span and don’t include timestamps (use an Event for information about events that happen at a specific time). Attributes allow you to query, group, or otherwise analyze traces and spans.

The [OpenTelemetry Spec](https://github.com/open-telemetry/opentelemetry-specification/) defines standard attributes that you should use, for example StatusCode and SpanKind).

#### Status

Status is a special, standardized property for a span. It may be set to values like OK, Cancelled, and Permission Denied.

#### SpanKind

SpanKind is another standardized span property. The SpanKind property provides useful performance context in a trace - does this span call a remote system? Does it serve requests from remote systems? Does it do work asynchronously off of a queue? All of this information is useful in performance analysis. The supported values of SpanKind are CLIENT, SERVER, PRODUCER, CONSUMER, and INTERNAL.

#### User-Defined

You can also create your own attribute key/value pairs so that the information you know you'll need to understand your system are available to you.

Here are a few examples:

```
db.type: cassandra
db.url: mysql://db.example.com:3306
net.transport: IP.TCP
net.peer.ip: 127.0.0.1
By following these practices, your observability tools may be able to provide more useful information to you.
```

### Events

Events contain a name, a timestamp, and an optional set of Attributes, along with a timestamp. Events represent an event that occurred at a specific time within a span’s workload.

Here are some examples of events: t:3, name:log, message:“retrieved 400 records” t:5, name:image-generated, image.x:408, image.y:552, image.size:2055 KB

## Here's an example of a Span

<p align="center"><img src="../images/example.png?raw=true"/></p>